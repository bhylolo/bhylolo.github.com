# 敏捷软件开发
**敏捷软件开发** 

*Agile software Development* 是一种软件开发方法，基于迭代和增量开发，通过自组织,跨团队，沟通协作完成开发工作。

> 2001年2月11日到13日，17位软件开发领域的领军人物聚集在美国犹他州的滑雪胜地鸟（Snowbird）雪场。经过两天的讨论，“敏捷”（Agile）这个词为全体聚会者所接受，用以概括一套全新的软件开发价值观。这套价值观，通过一份简明扼要的《敏捷宣言》，传递给世界，宣告了敏捷开发运动的开始。

### 敏捷的价值观

- 个体互动，高于流程和文档
- 与客户合作，高于合同谈判
- 响应变化，高于遵循计划
- 交付能工作的软件，高于详尽的文档

### 敏捷开发12条准则
1. 最高目标是，通过尽早和持续地交付有价值的软件来满足客户
2. 欢迎对需求提出变更——即使是在项目开发后期。要善于利用需求变更，帮助客户获得竞争优势
3. 要不断交付可用的软件，周期从几周到几个月不等，且越短越好
4. 项目过程中，业务人员与开发人员必须在一起工作
5. 要善于激励项目人员，给他们以所需要的环境和支持，并相信他们能够完成任务
6. 无论是团队内还是团队间，最有效的沟通方法是面对面的交谈
7. 可用的软件是衡量进度的主要指标
8. 敏捷过程提倡可持续的开发。项目方、开发人员和用户应该能够保持恒久稳定的进展速度
9. 对技术的精益求精以及对设计的不断完善将提升敏捷性
10. 要做到简洁，即尽最大可能减少不必要的工作。这是一门艺术
11. 最佳的架构、需求和设计出自于自组织的团队（self-organizing teams）
12. 团队要定期反省如何能够做到更有效，并相应地调整团队的行为

<h3 id="practice"> 敏捷实践</h3>

- [Pair Programming 结对编程](#pp)
- [TDD测试驱动开发](#tdd)
- [KanBan看板](#kanban)
- [XP极限编程](#xp)
- [Scrum](#scrum)
- [Trouble Shooting](#issue)

---

<h2 id="pp">Pair Programming 结对编程</h2>
Pair Programming 结对编程模式：
 - 流模式（Flow）——两个程序员共同从事一个有挑战性的问题。
 - 指导模式（Coaching）——老练的程序员在解决问题方面有经验和知识，可以与其他不能有效地独自解决问题的程序员分享。

![结对编程](https://upload.wikimedia.org/wikipedia/commons/a/af/Pair_programming_1.jpg)

---
<h2 id="tdd">Test-driven development 测试驱动开发</h2>
测试驱动开发（TDD/Test-Driven Development） 是指以测试用例为出发点，不写一行代码的情况下，编写单元测试（不是指测试人员驱动开发人员搞开发），然后开始编写代码使之通过测试。这样做的好处是直指目标，达到目标被视为最高优先级。TDD的执行离不开重构，因为软件开发通常是通过不断的重构达到最优的代码，用以实现：不过度设计、不做偏。它的大概流程如下图所示：

![TDD](https://upload.wikimedia.org/wikipedia/commons/0/0b/TDD_Global_Lifecycle.png)

---
<h2 id="kanban">KanBan看板</h2>

![KanBan](https://upload.wikimedia.org/wikipedia/commons/c/c2/Sample_Kanban_Board.png)

---
<h2 id="xp">XP极限编程</h2>

**XP** 是一个轻量级的、灵巧的软件开发方法；同时它也是一个非常严谨和周密的方法。它的基础和价值观是交流、朴素、反馈和勇气。即任何一个软件项目都可以从四个方面入手进行改善：加强交流；从简单做起；寻求反馈；勇于实事求是。XP是一种近螺旋式的开发方法，它将复杂的开发过程分解为一个个相对比较简单的小周期；通过积极的交流、反馈以及其它一系列的方法，开发人员和客户可以非常清楚开发进度、变化、待解决的问题和潜在的困难等，并根据实际情况及时地调整开发过程。

### 什么叫XP 
如果某个实践好，那就做到极限
- 如果代码评审好，那就总做代码评审（结对编程）
- 如果测试好，那就让每个开发人员都做测试（单元测试）
- 如果设计好，那就让每个开发人员天天做重构refectoring
- 如果简单就是好的，那就尽可能的选择简单的方法来实现功能
- 如果架构重要，那就让每个人时刻了解、完善架构
- 如果集成测试重要，那每天都做持续集成
- 如果短迭代好，那就让迭代变得极短

### XP的四个核心工程活动
- 编码
- 测试
- 倾听
- 设计

### XP的价值
- 沟通
- 简洁。*宁可用简单的方法来实现功能，也不要预测未来，不要实现大而全的功能，如果需要，将来再改，坚决避免开发出没人用的功能*
- 反馈
- 勇气

### XP的五个基本原则
- 快速反馈
- 简洁至上
- 增量变更
- 拥抱变化
- 质量至上

### XP的十二条实践
- 计划活动 *the planning game*
- 小版本 *small releases*
- 隐喻 *metaphor* ：用一个简单，通用的描述系统功能的故事来指导所有的开发
- 简单设计 *simple design*
- 测试 *testing*
- 重构 *refactoring* ：在不改变系统功能的前提下，开发人员不断的调整代码结构，消除重复，改善代码可读性，简化代码复杂程度，让代码变得更灵活
- 结对编程 *pair programming* ：所有的程序都是由两个程序员在一台机器上写出的
- 代码共享 *collective ownership* ：任何人都可以随时随地修改系统中的代码
- 持续集成 *continuous integration* ：每当完成一个任务后就进行集成和构建，有可能每天会要多次集成构建
- 不加班 *40 hour week* ：不能允许团队连续加班两周
- 现场客户 *on-site customer* ：有一个真正的用户自始至终都参与团队开发，随时回答团队的问题
- 代码标准 *coding standards* ：所有的程序员都遵循同样的编码规范要求

---
<h2 id="scrum">Scrum</h2>

- [哲学](#philosophy)
- [框架](#framework)
- [最佳实践](#practice)

<h3 id="philosophy" />

### 关键价值
- 透明
- 解释
- 调整

### 实践艺术
- 自我管理
- 管理者从监控到服务型的转变
- 追求问题的解决而不是最佳解决方案
- 对工程师能力提升和自律的要求

<h3 id="framework">框架</h3>

![framework](https://upload.wikimedia.org/wikipedia/commons/d/df/Scrum_Framework.png)

#### 重要文档
- [需求池 *Product backlog*](#pb)
- [冲刺任务列表 *Sprint backlog*](#sb)
- [燃尽图 *Burn down chart*](#bd)

<h5 id= "pb">需求池 Product backlog</h5>
由产品经理（product owner）发布、管理，将产品所有可能的需求都包含在其中，并排列好优先级。对于开发团队，PB是唯一的需求入口，PO在制作PB的时候只需要有效的支持开发，不需要支持维护。

- 它是一个列表，罗列出所有项目中希望要做的工作，里面包含：
  - Features
  - Bugs
  - Technical work
  - Knowledge acquisition知识获得，例如培训资料
  - Technical debt 技术债
- 里面所有的项目都应有优先级
- 由product owner 来确定、调整其优先级
- 对于开发团队，PB是唯一的需求入口，PO在制作PB的时候只需要有效的支持开发
- 列出的所有工作应该是high-level的，详细的内容会在后面添加
 > 细化到什么程度just enough， 什么时机细化just in time

- PB应当方便从文档转换成其他形式，以便于讨论。

<h5 id= "sb">冲刺任务列表 Sprint backlog</h5>
由跨职能团队从PB中选取一定的任务放在其中，作为每一个迭代的目标，每一个需求被分解成不同的任务。

![taskboard](https://upload.wikimedia.org/wikipedia/commons/1/1b/Scrum_task_board.jpg)

<h5 id="bd">燃尽图 Burn down chart</h5>
分为迭代内部管理的燃尽图，确认迭代的进度；另一种，是PB管理的燃尽图，在每次迭代结束后更新，监督整个项目的完成情况。

![dailyburndown](https://upload.wikimedia.org/wikipedia/commons/8/8e/SampleBurndownChart.svg)

![releaseburnup](https://upload.wikimedia.org/wikipedia/commons/4/4d/SampleBurnupChart.png)

#### 角色
- 产品经理 *Product owner* ：把控产品的方向，确保最终的产品就是用户所需要的。产品的远景，产品发布计划，判断每一个需求的业务价值、重要性、优先级，的收集用户的 反馈。
- Scrum master： 保证PO和team 能够正常的沟通、协同，确保整个团队不受外界干扰。
- 开发 *Team/Leader* ：决定如何做，做估算，每次迭代怎么做。所有的需求来源只从PO来，由PO收集所有的客户的需求和反馈。将每一个需求分解成对应的任务。

#### 活动
- 需求列表梳理 *Product backlog grooming* ：一般是在迭代的第二周开展的，根据目前的状况，为项目下一个迭代做准备。
- 冲刺计划（Sprint planning）
  - 每一个Sprint时长一般为2周，最短不少于1周，最长不超过4周
  - 任务来自于需求池PB
  - 确定哪些UserStory（功能）将在接下来的迭代中做
  - 是由用户告知的，希望系统应该如何工作的
  - 通常是卡片形式，并有估算和注释
  - 是工程师和PO、业务人员讨论后的结果
  - 验收标准
  - 细化粒度，确保是能在一周内完成

  ![sp](https://upload.wikimedia.org/wikipedia/commons/5/58/Scrum_process.svg)

- 站立会议 *Daily scrum*
  - 时长：每日早上 5~15分钟
  - 与会人员：Team中全体成员
  - 内容
  - 回顾昨天工作完成情况
  - 简单描述今天工作内容
  - 遇到哪些问题、困难
  - 要点
  - Team Leader了解项目、团队实际情况
  - 发现异常问题
  - 如有异常问题等，不在例会上讨论，而是结束后和特定人专门讨论

  ![daily scrum](https://upload.wikimedia.org/wikipedia/commons/4/4a/Daily_sprint_meeting.jpg)

- 阶段工作内容展示 *Sprint review* ：每次sprint结束后，用来演示sprint达成的目标，完成的功能，听取用户反馈
  - 时机：每次Sprint结束之后
  - 参与者：Team、PO、Scrum Master
  - 内容：Sprint计划中承诺的内容
  - 成果：一个可用的产品，包含新功能的

 > 标准定义
 > - 可用 不等于 可发布
 > - 最低标准是：通过单元测试
 > - 最高标准是：通过全部测试
 > - 采用何种标准，由团队决定
 
- 回顾 *Retrospective* ：每次sprint结束之后，由团队内部人员参加的，反思这次sprint中哪些环节做的比较好，哪些环节做的不够
  - 时机：Sprint review之后
  - 参与者：Team
  - 内容
  - 回顾本次Sprint中的优缺点
  - 评估团队开发效率，为下次估算做基础
  - 发现问题
  - 评估产品风险
  - 评估技术债

<h3 id="practice">最佳实践</h3>

#### 交付客户想要的软件

- 在设计方面，做决定是一定要有开发参与，但开发不能做所有决定，尤其是不能针对业务方面的决定
  - 项目经理一个重要的守则是，判断哪些是自己决定不了的，应该让客户来决定，当遇到会影响到系统行为和使用的问题，一点要告知业务负责人。
  - 用业务负责人能够理解的语言，详细解释所遇到的问题，让他们做决定。
    - 不要用低级别，没有价值的问题打扰业务人员，如果问题对他们的业务没有影响，就是没有价值的。
    - 不要随意假设低级别的问题不会影响他们的业务，能影响到他们业务的问题，都是有价值的。
    - 即使是业务人员回答“我不知道”，这也是一个称心如意的答案，也可能是因为他们没有想到那么远，也许是他们只有看到运行结果才能做出决定，或者是其他什么情况，这是要尽可能的给业务人员更多的建议，并且在代码实现的时候，这里要考虑到将来可能会遇到变化。
  - 在和客户讨论之前，尽可能多准备几套方案以供挑选，介绍每种方案的优缺点，和潜在的成本利益。
  - 书面记录客户作出的决定，并注明原因。无论客户作出了什么样的决定，双方都必须接受它。当之后出现变化的时候，就可以公正的就成本和时间重新谈判。
- 在开发过程中，始终要保持你已经提交的代码应该随时可以运行。
  - 需要一个版本管理工具来统一管理团队中的代码
  - 每一次提交前，都要从代码库中更新系统其他部分的最新代码，在本地运行测试，并通过所有单元测试用例，以及通过系统中其他部分的测试用例。
    - 如果编译和单元测试都通过了，就可提交到代码库
    - 如果出现了代码冲突，或不能通过编译以及测试的话，需要立即告知相关人员，并确保他们也是按照这个规则在更新代码库的。
  - 最好有一个自动化的持续集成系统，在后台不断的检出、构建、运行测试用例，如果在这个过程中发现问题，可以通过邮件自动通知开发人员。
  - 如果需要在多个平台上测试，就只要在每个平台上设置一个持续集成的系统就可以了。不同的平台，就可能会有不同的问题，使用持续集成在各个平台上自动的运行测试，就是积极的寻找问题，而不是等问题来找你。
  - 如果正在进行的是一次重大的修改，这个修改可能会破坏系统的可用性，最好的方式是，将这一情况告知团队的所有成员，并且在版本控制系统中添加一个分支，专门处理这个问题。千万不能让系统处于长期不可发布状态，同时又不能撤销。
  - 有时候，不得不需要做一些重大改动，使得整个系统需要经历一段时间不可用，这应该是例外，千万不能养成习惯。
  - 系统在开发过程中，要持续集成。持续集成和独立开发之间并不矛盾
    - 使用mock对象来模拟真实对象或子系统，来隔离对象之间的依赖关系，使集成和测试更容易。
    - 成功的集成，意味着所有的单元测试不停的通过，即所谓，首先不要造成伤害
    - 对于原型和实验代码，可以进行独立开发，不必在集成上浪费太多的时间，但不能独立开发的时间太长，一旦有了经验以后，就要快速的开始集成。
  - 软件在一开始就能自动化部署，受益良多
    - 在给客户演示的时候，会有一种更专业感
    - 有助于将软硬件所依赖的环境，统一检查、安装
    - 在没有询问用户之前，安装程序决不能删除用户数据
    - 用户应该可以安全并且完整的卸载安装程序，这一点，在测试人员的环境中尤其重要。
    - 如果安装脚本十分复杂，就意味着软件可能维护成本变得很高。
    - 每一版本的安装包都应该有标签，无论是放在文件服务器上，还是刻录成光盘，对于测试人员或用户使用，都将是十分方便。
- 使用演示，获得不断的用户反馈
  - 应该定期的，例如每一次迭代结束，就与客户会务，向他们演示已经完成的功能。与客户持续的演示系统，不但能够不断的从客户那里获得反馈，从而使所有都能了解到需求和目标，还能使用户了解到真实的软件开发进度，用户还能根据进度来排列需求的优先级。
    - 也许一开始用户会被频繁的演示所惊吓到，但要使他们明白，这是为了降低项目风险，确保他们的利益
    - 演示的频率要和客户协商好，按照他们能接受的最短周期来进行
    - 演示的目的是让用户提出反馈，所以能演示的系统，至少应该是实现一定的功能和稳定性的。
- 倾听用户的声音
  - 不管是软件的bug，还是文档的bug，还是对用户理解上的偏差，这都是团队的问题，而不是用户的问题。每一个抱怨背后都隐藏了一个事实，找出真相，修复真正的问题。
  - 没有愚蠢的用户，只有自大的程序员。
  - 如果真的无法通过代码来解决，那就考虑修改文档和开展培训来弥补。
  - 牢记，用户可能会阅读所有的文档，但也可能，不会。
- 面对一个固定价格的合同，对于敏捷团队，可能是一大挑战，可以采用以下的方式
  - 主动提出，先构建系统最初的、小的、但是有用的部分，通过实现一系列小的功能，来完成第一迭代，通过第一次迭代的经验获得对于整个项目成本和进度的估算方法。在第一次迭代技术后，用户决定，要么进入下一次迭代，要么支付一定的费用终止合同。由用户来控制和选择，他们想要的功能和预算。
  - 如果不得不要提供一个固定价格合同，那高超的估算技巧是必不可少的。

#### 正确的设计

- 在敏捷开发中，设计仍然是必不可少的。
- 设计分为：战略层面和战术层面。在项目的一开始，在做战略层面设计的时候，要避免过度设计。
  - 对于战略层面设计，好的设计应该是正确的，而不是精确的，它不应该设计任何不确定或可能发生变化的细节，它提出的是目标，而不是具体的处方。
    - 可以定义：类——做什么——需要和哪些其他对象一起协作。
    - 不要定义具体的方法，参数，字段和对象间的精确精确交互顺序细节。
    - 白板，草图，便利贴都是很好的设计工具，复杂的建模工具只会分散精力，而不是启发思维。

#### 正确的开发

- 代码要清晰的表达意图，而不是写讨巧的代码。代码可以被读懂，不是因为其中有注释，而是因为它本身就优雅而清晰
  - 使用正确的命名，通过命名来传递准确的信息和意图。也不必用冗长的名称去替换大家已经习惯的名称。
  - 得当的使用空格、缩进、分行。
  - 逻辑分离清晰
  - 表达式简洁
  - 注释要能传递有意义的信息，应该是上述内容之外的信息，在代码就能传递意图的地方，就不需要用注释。
    - 目的：为什么需要这个方法
    - 前置条件：方法需要怎样的输入，对象需要处于何种状态
    - 后置条件：方法执行成功后，会返回什么值，对象会处于何种状态。
    - 异常：可能会发生什么样的异常。
  - 当重写方法的时候，原有的关于方法意图和约束的注释，应该予以保留。
  - 对于自己写的代码，确保自己在一年以后，仍然可以只读一遍就知道其运行机制。对于团队协同开发，即便整个代码的编写都是按照上述要求来做，但成员之间水平的差异，仍然可能导致对于结构的理解困难程度不一样，所以保持一致的水平和共同进步，是极为重要的。唯有自己看自己以前写的代码，是肯定不会出现，阅读者的水平低于编写者。
- 编写能获得反馈的代码——自动化单元测试，它将是程序的守护天使。
  - 在编程之前，先写测试
  - 单元测试不是别人的任务，它是属于程序员实现编码的一部分
  - 在用代码来测试值的时候，首先要清楚自己需要测试的内容
  - 要让单元测试能自动运行，在每次构建、提交、发布之前都自动运行。
  - 有了单元测试作为守护，你就可以放心的实验、重新设计和重构代码，而不必如履薄冰。
  - 程序员同时编写实现代码和单元测试代码，能够帮助其思考正面、反面和异常情况。
  - 当你在学习和使用一个新的API的时候，为它编写单元测试，是加深理解的最好方式，同时，当你在编写一个功能的时候，单元测试代码将是最精确的文档。
  - 单元测试要达到一定的覆盖率，才能真正的发挥作用。
  - 并不是测试越多质量就会越高，测试必须是有效的，如果测试无法发现任何问题，也许是因为他没有测对路子。
- 采用增量式编程。所谓增量式编程就是指，在很短的编辑/构建/测试循环中编写代码，这要比花费很长时间，仅仅只做编码要好得多，它将迫使你创建更清晰、简单、易于维护的代码。
  - 在编译和构建的过程中，暂时远离代码的细节，停下来想一想，是保证不会偏离正确方向的好办法。
  - 没有什么任务是能够一个人在一天之内就完成的。如果你是因为害怕，一旦停下来，明天就会忘记所要写的东西的话，那一定会是个不好的设计。当在编码的时候，问题就已经复杂到容易搞晕，那维护的时候就一定更困难。
  - 要休息的话，就要好好休息，在休息时，一定要远离键盘。
  - 要像重构代码一样，重构测试，而且要经常重构测试。
- 要让你的产品尽可能的好，你自己就得积极的使用它。
- 不要过度开发，重点是：什么是实现特定功能的最低成本。
  - 一开始就编写单元测试代码，有助于消除多余的类，简化代码结构防止走偏。迫使你一开始就思考可用性和便利性。
  - 将TDD作为设计工具，先用它，再实现它，你可以专注于设计接口，而不会被具体的实现干扰。
  - 如果领域专家已经提供了业务的算法、或者方程，那就为他们单独设计一套可独立运行的测试，并且这个测试要像其他测试一样可以自动运行。
    - 不要期望所有客户都能给你提供正确的数据，如果他们总是能提供正确的数据，那就不要新的系统了。
    - 使用客户的业务逻辑。
- 度量真实的进度
  - 不应该去计算工作量的完成百分比，而应该测量剩下工作的百分比。
  - 当最后完成任务的时候，需要准确的知道这个任务真正花费的时间，不管是否超过最初的估算，这将能作为下一次估算的参考。
  - 准确度量进度的方法是使用ToDo  list，当完成一个任务后，就将它划掉，当有新的任务要添加进来，要先给它排好优先级，再加入到list中。
  - 每个工作日，每个团队成员都要评估完成一个任务还需要多少时间，不管怎样，一旦所有任务估算总和超过了一个sprint时间，就要将一部分任务移到下一个sprint。
  - 关注功能，而不是时间表
  - 正确认识有效时间。一周40小时工作时间，真正用于编码的，要减去会议、电话、邮件以及其他活动所耗费的时间。
- 在团队中实行轮换责任制，让每个成员都可以接触到不同部分的代码，如果可能的话，结对编程是一种高效的方式。
- 做代码复查。
  - 要寻找深藏不露的程序bug，代码复查，其效果是任何已知的测试效果的两倍，而且是移除80%缺陷的唯一已知方式。
  - 代码刚刚完成时，是寻找问题的最佳时机，如果放任不管，它也不会变得更好。
  - 代码复查看重的是
    - 代码能否被读懂和理解
    - 是否有任何明显的错误
    - 代码是否会对应用其他部分产生不良影响
    - 是否存在重读代码
    - 是否存在可改进或重构的部分
  - 代码审查时需要注意
    - 不进行思考的代码审查是没有任何价值的
    - 代码审查需要积极的评估代码的设计和清晰程度，而不是只是考虑变量名和代码格式是否符合组织标准
    - 同样的逻辑，不同人来开发可能实现方式不同，但差异并不意味着不好，除非你可以让某段代码明确变得更好，否则不要随便批评别人的代码
    - 如果不及时跟进讨论中给出的建议，代码审查是没有价值的，需要安排跟进会议和代码标记系统，来标识需要完成和已经完成的工作
    - 确保代码复查参与人员每次得到反馈结果。
  
#### 如何确保项目能够按时按量的交付
- 有一个知道自己速率的、密切合作的跨职能团队
- 通过每日例会实现同步开发及问题的及时解决，尽可能在识别出开发障碍后的24小时之内将其清除。
- 细化用户故事，让其粒度足够小，能够在一周之内完成。
- 对每一条迭代需求列表中的需求，都有明确的严格的“完成”done
- 让每日持续集成制度化，这样能够最大限度的降低发布工作量的投入
- 冲刺sprint中对团队工作的零干扰，让团队专注于开发
  
#### 如何做到团队的自我管理
- 明确scrum role角色的职责，团队清楚自己应有的担当，并作出承诺
- 冲刺评审会sprint review对已经开发好的软件特性作出反馈，使得团队能够及时的调整产品的方向，降低产品变更的成本。
- 冲刺回顾会议sprint retrospective对开发过程的反馈，使得团队能够及时的纠正问题，持续的改进过程，降低犯错带来的成本
- 每日例会daily scrum（standup）让每个成员对团队负责，努力做好自己的工作，不拖整个团队的后腿
- 由团队决定哪些需求任务放入迭代需求列表sprint backlog，由团队决定如何实现需求特性，相信他们会把工作做好，会在实践中提高能力。
  
#### 如何让开发过程变得透明
- 正确使用scrum的三个文档product backlog，sprint backlog，burn down chart
- 设计管理好你的敏捷岛，用最简明的方式展示sprint，version statue
- 开好所有scrum中的会议，让透明的过程服务于必要的检查和调整。 
  
#### 如何获得产品的反馈并及时调整
- Sprint view 是获取反馈的最好时机，对于需求不明确的项目，这个会议更是最重要的。
- 产品需求列表的细化会议，是团队和产品经理形成默契，一起加深需求理解的重要活动，也是平衡产品需求价值和成本的好机会
- 在整个开发过程中，团队可以随时和产品经理沟通，随时确认实现的需求
  
#### 如何保证可持续的开发节奏
- scrum中时间盒 time box指的是固定的sprint周期，固定的会议时间，它创造了可预测的工作步调
- 团队的速率，也是形成团队开发节奏的重要保障。
- 采用固定的、有规律的时间长度进行迭代，
  - 这个时间应该是团队能接受的最舒服可行的长度。
  - 如果每次迭代的时间都不够用，要么是任务太大，要么是迭代时间太短。
  - 保持事件之间稳定重复的时间间隔，有助于处理重复的任务，例如，复审，测试，集成，发布。
  - 当你遇到艰难抉择的时刻，最后期限会促使你下定决心。
  - 当面对突发情况，例如有更紧急的任务，或者遇到预料之外的困难，不应当改变迭代周期，但是可以灵活调整迭代中的任务，换句话说，你不会改变时间，但会改变功能。
  - 有利于避免加班。
  - 每一次迭代结束，都能达到一点小小的成功，即便是小小的成功也能产生很大的激励。
- scrum中固定的例会，固定的工作环境，共同遵守的工程实践，都有助于开发节奏的形成
- scrum对技术债务的管理要求，防止团队只追求速度，有助于把握节奏。 

####  如何维护好版本计划
- 每次sprint之后计算团队的速率，让产品经理知道团队的开发能力，每次sprint能实现多少功能，让版本计划变得有意义
- 根据团队的能力来调整计划，是保证计划准确的主要手段
- 产品经理根据最新进展对产品需求列表进行维护，是确保在进度压力大的情况下，首先发布对用户最有价值的功能的保障
- 远粗近细的原则，让产品经理和团队高效完成版本计划工作、

####  如何让团队比较准确的计划每一次Sprint
- 赋予团队权利，让团队决定每次sprint完成哪些user story
- 团队速率可以让团队自己选择每次sprint完成多少user story
- Product backlog的优先级次序，可以让团队自己选择完成哪些优先级高的user story
- INVEST的原则和需求细化会议让在极短的sprint周期中完成可发布的软件功能变得可行，这也是团队做sprint plan的基础

####  如何有效控制“带病迭代”
- 敏捷对卓越技术的追求以明确完成done标准是控制带病迭代的关键
- 持续集成等有效的工程实践也是sprint质量的保证
- Sprint review会议让团队及时的发现带来隐患的做法，并及时在下一次迭代中纠正
- 燃尽图burn down chart能让团队及时的发现隐患对团队效率带来的影响
- 团队的自律及相互负责的文化使得不鼓励走“技术捷径”
- XP是辅助scrum解决带病迭代的好办法

####  如何设计好产品功能
> *找到痛点最有效的方式是，看它能够用最简洁语言描述出来*

- Elevator statement 电梯测试：在电梯到达一楼之前，向对方说明产品特点。在2分钟内向客户解释产品，用简短的语言描述产品的优势
  - 为谁
  - 产品给客户带来的价值
  - 是属于哪一类的产品
  - 和竞争对手比，好在哪里
  - 产品的主要区分点和价值点
- Vision box 产品包装盒上的说明
  - 假设，可能并没有，有一个盒子来装这个产品
  - 印刷在盒子上，使用3-4条来描述这个产品
- Press release 新闻稿
- Magazine review 杂志上的介绍

####  如何建立一个敏捷团队
- 设计、编程能力
- 理解业务需求问题能力，所有成员必须都具备一定业务背景知识，能够和产品经理沟通需求，正确理解需求支持设计、开发和测试工作。
- 理解软件规范及规则能力，需要有领域专家。
- 设计用户界面的能力，需要有类似美工的人员。
- 清楚理解模块间调用关系，对于复杂的系统要有接口设计的能力。
- 识别软件中错误的能力，需要有对业务、设计、白盒测试和测试技术都熟悉的人。
- 处理好团队外关系的能力，需要有项目管理人员
- 熟悉敏捷实践，需要了解如何让敏捷实践有效的在团队中落地。
- 具备持续改进的习惯，一开始可能需要一个敏捷教练。

#### 如何做团队决策
在做团体决策时，应该遵循以下规则
- 在会议的一开始就设定结束期限，在结束期限到来时，必须拿出一个结果，哪怕不是最优方案。
- 逆向思维。对于每一种方案，要看到正面，也要尽可能多的看到反面，然后将每一种方案的正面和反面列出，有利于客观的，不带感情色彩的仲裁。
- 设立仲裁人。仲裁人需要维持会议的正常进行，保持每个人都能畅通的表达自己的意见，以及在出现争论的时候，作为最后的决定者。作为仲裁人，应该更注重于协调，而不要注重发表自己的意见。
- 支持已经作出的决定。团队的每位成员都应该积极支持以及作出的决定，哪怕当初持反对意见的人，哪怕这个决定在理想条件下并不是最优方案。
  - 在开始寻找『最佳方案』之前，要对『最佳』的含义定义并达成共识，通常，程序员眼中的最佳方案，并不是用户认为的最佳。
  - 实际上并不存在『最佳』，通常只是针对某个特定条件下。
- 应该意识到，设计总是充满妥协。在工作中不感情用事是需要克制力的，也是成熟的标志，但这需要有人带头身体力行的去感染别人。
- 需要在团队中建立起积极的氛围，这种氛围是保持整个团队总是朝着团队目标前进，总是关注于有价值的问题，避免成员间出现勾心斗角，这就需要做到：
  - 对事不对人。在言语上，选用合适礼貌的词语和理由来陈述自己的观点，解释反对的原因，提出明确的问题，而避免否定对方个人能力，避免在团体会议上明确指出个人的缺点并否定其观点。
  - 每个成员都需要有勇气。勇气指的是，当每个人发现问题的时候，特别是这个问题是自己引起的，都要能坦诚的说出来，让整个团队都知晓发生了什么情况（譬如，自己的进度可能会拖延了，在交付期限快要到来时发现自己没有能力完成任务的最关键的部分，或者在接近写完的时候却发现需求理解错误了）。勇于承认自己的过错和无知，会让他人明确知道风险，从而不会总是提心吊胆未知的雷区。一次重大进度拖延的原因，会为下一次估算提供重要的经验；一个需求的误解，可能其他人员也有相同的误解；一次重大的错误，会是整个团队学习的机会。
  - 具有勇气的时候，要避免鲁莽。勇气和鲁莽之间最根本的区别是，勇气是将问题告知团队中其他成员，但不自己做决定；鲁莽是指，自己替代团队讨论而做决定。最有可能引起鲁莽的是，程序员对自己技术水平自信，而忽略了其他因素。
  - 团队中还应该避免沉默，即盲目的接受所有的观点。保持沉默的缺点是，可能成员并没有一个积极的心态去实现团队目标，或者总是害怕承担更多的任务和责任。没有说过任何错话，没有犯过任何错误，很可能是说明你没有在努力工作。

#### 如何在团队中引入新技术
- 作为决策者，当试图想向团队中引入一种新技术的时候，应该具有保守的态度。
  - 首先要明白，为什么要引入这种新技术，它试图解决什么问题，适用于什么样的场景，有哪些优势和劣势。开发一个原型系统，去验证评估新技术。
  - 你是如何了解这种新技术的特点的，是通过市场的宣传？别人的推荐？道听途说？
  - 新技术的功能真的是你解决问题所需要的吗，它们之间的契合度是多少。
  - 它是具有专利的，还是开放的，开放到什么程度
  - 具有可替代性吗
  - 维护成本是多少。包括，理解、修改、扩展的难易程度，懂得这项技术的人员在市面上多吗，整个方案的花费是否超过了要解决的问题。
  - 每一项技术都有优缺点，但不要轻易开发那些你很容易就能下载到的东西，任何时候都从最基础的地方开发你所要的东西，都是相当危险和昂贵的。
- 尽量让讲座走入团队
  - 坚持持续有计划的讲座，要小步前进，而不要采用间隔时间长的马拉松式的会议。
  - 不要局限于纯技术的主题，非技术类的，例如项目估算、沟通技巧等，也会对团队有帮助。
  - 推荐和带领大家一起来读一本有价值的书。
  - 不要将讲座变为设计讨论会，具体问题最好留到相关的会议中去。

#### 如何接手一个你并不了解的系统
当你面对需要修复一个系统中的问题，但你又对它并不熟悉，同时还受到进度的压力；或者你正在接手设计一套系统，但你对这个领域需求并不了解。**为什么**是一个非常好的问题，当你在理解一个问题的时候，在递进的问出五个**为什么**以后，往往就能更接近真相。
- 在不停的问为什么的时候，不能只满足于别人告诉你的答案，而要直到自己明白问题的根源为止
- 在问“为什么”的时候，一定要能够把握始终聚焦在目标问题上，不能跑题，跑题的为什么是不能提供帮助的。
- 当在提问**为什么**的时候，可能会面临反问“你为什么要问这个问题”，所以在提问之前最好想好理由，同时，这也会有助于你提出恰当的问题。
- **这个，我不知道**是一个很好的起点。
		
如果你是某个领域的专家，引导提问者在正确的方向上自己思考问题，是一个有效的措施。
- 用问题来回答问题，可以引导提问人走向正确的道路。
- 如果对方真的陷入了胶着状态，就不要再折磨他了，直接告诉他答案，然后再解释为什么是这样的。

#### 如何编写和维护代码
- 不要孤立的编码，团队成员需要花一些时间来理解其他人编写的代码，以确保他们的代码是可读和可理解的。阅读代码的一种实践是，在团队内实行代码复查。这不仅有助于更好的理解代码，也是尽早发现bug的最有效的方法之一。另一种实践就是编写单元测试，单元测试能够迫使你将代码分成可管理的多个小块，同时，直接阅读单元测试用例——它也是一篇可执行的文档，能够帮助你更彻底的理解代码。
- 不要快速简单的修复bug，需要投入一些时间和精力以保持代码的整洁。
- 平衡的艺术：不需要对于系统中每一块代码的细节，实现的步骤都很清楚，但需要理解，其整体是如何工作的，各个部分是如何交互的，以及如何使一段代码有效的工作。如果有一段代码，其他人很难看懂，就意味着即便是作者本人也会很难维护它，那就应该让这段代码变得简单些。

---
<h2 id="ref">引用</h2>
以上所有图片资源，来自Wikipedia。

---
<h2 id="issue">Trouble Shooting</h2>

### **Agile** 不只是 **Scrum**
敏捷包含多种[实践](#practice)，其中Scrum受到软件开发的关注是由于，Scrum所针对的团队规模一般不超过10人，此规模的团队不至于太小而做不出产品级成果，也不至于太大而占用更多的资源，从而有更高的风险。

但更小或更大的团队规模，也不一定完全适合Scrum。
- 更小的团队，由于沟通成本更低，可以选择更自由更适合自身的放式，而不必拘泥于Scrum的某些形式。
- 更大规模的团队，尤其是面对并不能持续集成、持续发布的产品，也不需要强求Scrum。

### Scrum的重要资产
- Product Backlog 重点在于
  1. 这是一份与外部成员沟通的结果，也是Team安排计划和计算成果的依据，同时也是产品需分析的结果。
  2. 当需要在某一层面了解系统的概况（既要比User Story具体，又要比系统设计抽象），这是一份很好的需求和设计说明书。
  3. 为Team在Sprint中提供了需求缓冲。
  4. 对于理想的Scrum模型，sprint backlog来自于product backlog，而product backlog是来自于customer、product owner和team leader共同制定的，两方的相互制约，使得product backlog会趋向于功能和成本的合理。
- Sprint Backlog
- Burn down Chart

### Scrum重要角色
1. Srcum Master
2. Product Owner

### Scrum的商务和财务意义
1. 将Customer纳入到Scrum中，明确需求，是保证最后product具有正确的功能和有商业价值
2. Scrum团队可以作为财务成本核算单元，帮助企业在财务层面监控研发成本
  - 对于直接产生商业合同的Scrum项目，更容易核算成本和计算利润
  - 对于不直接产生商业合同的项目，或维护类项目，可以根据product backlog核算工作量，通过每个burn down chart估算团队开发效率
3. 对于固定价格的合同，Scrum会面临很大的挑战。能在早期规划项目、评估风险是决定成败的关键。所以，做方案的能力尤为重要，所谓制作方案的能力，是指，能够识别核心需求（对于用户具有商业价值的功能）、了解如何搭建一套成熟可用的系统、哪些子系统可以有成熟的商业产品可替代、成本是多少。

### Scrum 面临的挑战
1. 并不是所有的项目都有customer，如何保证“做正确的事”
2. 选择合适的Scrum Master，确保其能够所服务的各个Team之间，协调资源，解决冲突
3. 对于遗留系统的维护，PO最大的挑战是，对于遗留系统的认知，不仅包括业务上、还包括技术上和历史债务

